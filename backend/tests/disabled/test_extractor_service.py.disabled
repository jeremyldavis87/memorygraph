import pytest
import asyncio
from unittest.mock import AsyncMock, patch
from fastapi.testclient import TestClient
import sys
import os

# Add the graph services to the path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'graph-services', 'extractor-service'))

from app.main import app as extractor_app
from app.extractors.triple_extractor import TripleExtractor

extractor_client = TestClient(extractor_app)

@pytest.fixture
def mock_llm():
    """Mock the LLM for testing"""
    with patch('app.extractors.triple_extractor.ChatOpenAI') as mock_chat:
        mock_instance = AsyncMock()
        mock_instance.ainvoke.return_value = AsyncMock(content='''
        {
          "entities": [
            {
              "name": "John Smith",
              "type": "Person",
              "properties": {"role": "Developer"},
              "confidence": 0.9
            },
            {
              "name": "Acme Corp",
              "type": "Organization",
              "properties": {"industry": "Technology"},
              "confidence": 0.8
            }
          ],
          "relationships": [
            {
              "subject": "John Smith",
              "predicate": "WORKS_FOR",
              "object": "Acme Corp",
              "confidence": 0.9,
              "properties": {}
            }
          ]
        }
        ''')
        mock_chat.return_value = mock_instance
        yield mock_instance

def test_extractor_health_check():
    """Test extractor service health endpoint"""
    response = extractor_client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    assert data["service"] == "extractor"

def test_extract_triples_sync(mock_llm):
    """Test synchronous triple extraction"""
    response = extractor_client.post("/extract", json={
        "content": "John Smith works for Acme Corp as a developer.",
        "title": "Team Update",
        "source_type": "rocketbook",
        "user_id": 1
    })
    
    assert response.status_code == 200
    data = response.json()
    assert "triples" in data
    assert "entities" in data
    assert "relationships" in data
    assert "processing_time" in data
    assert "model_used" in data
    assert len(data["triples"]) >= 1
    assert len(data["entities"]) >= 1
    assert len(data["relationships"]) >= 1

def test_extract_triples_async(mock_llm):
    """Test asynchronous triple extraction"""
    response = extractor_client.post("/extract/async", json={
        "note_id": 1,
        "content": "Sarah Johnson from TechCorp discussed the project timeline.",
        "title": "Client Meeting",
        "source_type": "rocketbook",
        "user_id": 1
    })
    
    assert response.status_code == 200
    data = response.json()
    assert "job_id" in data
    assert "status" in data
    assert "message" in data
    assert data["status"] == "queued"

def test_extract_triples_invalid_input():
    """Test extraction with invalid input"""
    response = extractor_client.post("/extract", json={
        "content": "",  # Empty content
        "title": "Empty Note",
        "source_type": "rocketbook",
        "user_id": 1
    })
    
    # Should still work but return minimal results
    assert response.status_code == 200
    data = response.json()
    assert "triples" in data
    assert "entities" in data
    assert "relationships" in data

def test_extract_triples_llm_error():
    """Test extraction when LLM fails"""
    with patch('app.extractors.triple_extractor.ChatOpenAI') as mock_chat:
        mock_instance = AsyncMock()
        mock_instance.ainvoke.side_effect = Exception("LLM service unavailable")
        mock_chat.return_value = mock_instance
        
        response = extractor_client.post("/extract", json={
            "content": "This should fail due to LLM error.",
            "title": "Test Note",
            "source_type": "rocketbook",
            "user_id": 1
        })
        
        assert response.status_code == 500
        data = response.json()
        assert "detail" in data
        assert "Extraction failed" in data["detail"]

def test_triple_extractor_initialization():
    """Test TripleExtractor initialization"""
    with patch.dict(os.environ, {
        'GRAPH_EXTRACTION_LLM_PROVIDER': 'openai',
        'GRAPH_EXTRACTION_MODEL': 'gpt-5-nano',
        'OPENAI_API_KEY': 'test-key'
    }):
        extractor = TripleExtractor()
        assert extractor.llm_provider == 'openai'
        assert extractor.model_name == 'gpt-5-nano'

def test_triple_extractor_unsupported_provider():
    """Test TripleExtractor with unsupported LLM provider"""
    with patch.dict(os.environ, {
        'GRAPH_EXTRACTION_LLM_PROVIDER': 'unsupported',
        'GRAPH_EXTRACTION_MODEL': 'gpt-5-nano',
        'OPENAI_API_KEY': 'test-key'
    }):
        with pytest.raises(ValueError, match="Unsupported LLM provider"):
            TripleExtractor()

def test_triple_extractor_parse_llm_response():
    """Test parsing LLM response"""
    extractor = TripleExtractor()
    
    # Test valid JSON response
    valid_response = '''
    {
      "entities": [
        {
          "name": "Test Entity",
          "type": "Person",
          "properties": {},
          "confidence": 0.8
        }
      ],
      "relationships": [
        {
          "subject": "Test Entity",
          "predicate": "RELATES_TO",
          "object": "Another Entity",
          "confidence": 0.7,
          "properties": {}
        }
      ]
    }
    '''
    
    entities, relationships = extractor._parse_llm_response(valid_response)
    assert len(entities) == 1
    assert len(relationships) == 1
    assert entities[0].name == "Test Entity"
    assert relationships[0].subject == "Test Entity"

def test_triple_extractor_fallback_parsing():
    """Test fallback parsing when JSON parsing fails"""
    extractor = TripleExtractor()
    
    # Test invalid JSON response
    invalid_response = "This is not valid JSON"
    
    entities, relationships = extractor._parse_llm_response(invalid_response)
    # Should return empty lists for invalid JSON
    assert len(entities) == 0
    assert len(relationships) == 0

def test_triple_extractor_create_triples():
    """Test creating triples from entities and relationships"""
    from app.extractors.triple_extractor import Entity, Relationship
    
    extractor = TripleExtractor()
    
    entities = [
        Entity(name="John", type="Person", confidence=0.9),
        Entity(name="Acme Corp", type="Organization", confidence=0.8)
    ]
    
    relationships = [
        Relationship(subject="John", predicate="WORKS_FOR", object="Acme Corp", confidence=0.9)
    ]
    
    triples = extractor._create_triples(entities, relationships)
    
    assert len(triples) == 3  # 2 entity triples + 1 relationship triple
    assert any(t["predicate"] == "INSTANCE_OF" for t in triples)
    assert any(t["predicate"] == "WORKS_FOR" for t in triples)

def test_triple_extractor_system_prompt():
    """Test system prompt generation"""
    extractor = TripleExtractor()
    system_prompt = extractor._get_system_prompt()
    
    assert "expert knowledge graph extraction" in system_prompt
    assert "extract only factual" in system_prompt
    assert "confidence scores" in system_prompt

def test_triple_extractor_extraction_prompt():
    """Test extraction prompt generation"""
    extractor = TripleExtractor()
    prompt = extractor._create_extraction_prompt(
        content="John works at Acme Corp",
        title="Team Update",
        source_type="rocketbook"
    )
    
    assert "John works at Acme Corp" in prompt
    assert "Team Update" in prompt
    assert "rocketbook" in prompt
    assert "entities" in prompt
    assert "relationships" in prompt
