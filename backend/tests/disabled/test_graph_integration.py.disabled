import pytest
import asyncio
from unittest.mock import AsyncMock, patch
from fastapi.testclient import TestClient
from app.main import app
from app.services.graph_client import graph_client, Triple

client = TestClient(app)

@pytest.fixture
def auth_headers(test_user):
    """Get authentication headers for testing"""
    response = client.post("/api/v1/auth/login", data={
        "username": "test@example.com",
        "password": "testpassword"
    })
    assert response.status_code == 200
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

@pytest.fixture
def mock_graph_services():
    """Mock all graph services for integration testing"""
    with patch('app.services.graph_client.graph_client') as mock_client:
        # Mock extract_triples
        mock_client.extract_triples = AsyncMock(return_value={
            "triples": [
                {
                    "subject": "John Smith",
                    "predicate": "WORKS_FOR",
                    "object": "Acme Corp",
                    "confidence": 0.9,
                    "entity_type": "Person",
                    "relationship_type": "WORKS_FOR",
                    "properties": {"role": "Developer"}
                },
                {
                    "subject": "Project Alpha",
                    "predicate": "PART_OF_PROJECT",
                    "object": "John Smith",
                    "confidence": 0.8,
                    "entity_type": "Project",
                    "relationship_type": "PART_OF_PROJECT",
                    "properties": {"status": "active"}
                }
            ],
            "entities": [
                {"name": "John Smith", "type": "Person", "confidence": 0.9},
                {"name": "Acme Corp", "type": "Organization", "confidence": 0.9},
                {"name": "Project Alpha", "type": "Project", "confidence": 0.8}
            ],
            "relationships": [
                {"subject": "John Smith", "predicate": "WORKS_FOR", "object": "Acme Corp", "confidence": 0.9},
                {"subject": "Project Alpha", "predicate": "PART_OF_PROJECT", "object": "John Smith", "confidence": 0.8}
            ],
            "processing_time": 1.5,
            "model_used": "gpt-5-nano"
        })
        
        # Mock bulk_insert_triples
        mock_client.bulk_insert_triples = AsyncMock(return_value={
            "inserted_count": 2,
            "merged_count": 0,
            "errors": [],
            "processing_time": 0.5
        })
        
        # Mock get_graph_context
        mock_client.get_graph_context = AsyncMock(return_value={
            "entities": [
                {"name": "John Smith", "type": "Person"},
                {"name": "Acme Corp", "type": "Organization"},
                {"name": "Project Alpha", "type": "Project"}
            ],
            "relationships": [
                {"subject": "John Smith", "predicate": "WORKS_FOR", "object": "Acme Corp"},
                {"subject": "Project Alpha", "predicate": "PART_OF_PROJECT", "object": "John Smith"}
            ],
            "context_summary": "Context includes: 1 Person: John Smith; 1 Organization: Acme Corp; 1 Project: Project Alpha; 2 relationships",
            "query_time": 0.3
        })
        
        # Mock get_graph_stats
        mock_client.get_graph_stats = AsyncMock(return_value={
            "total_nodes": 15,
            "entity_count": 12,
            "note_count": 3,
            "total_relationships": 8,
            "relationship_types": 5,
            "entity_type_distribution": [
                {"entity_type": "Person", "count": 5},
                {"entity_type": "Organization", "count": 3},
                {"entity_type": "Project", "count": 2}
            ]
        })
        
        # Mock health_check
        mock_client.health_check = AsyncMock(return_value={
            "extractor": {"status": "healthy", "service": "extractor", "neo4j": "connected"},
            "inserter": {"status": "healthy", "service": "inserter", "neo4j": "connected"},
            "retriever": {"status": "healthy", "service": "retriever", "neo4j": "connected"}
        })
        
        yield mock_client

def test_end_to_end_graph_processing(auth_headers, mock_graph_services):
    """Test complete graph processing pipeline from note creation to context retrieval"""
    
    # Step 1: Create a note (should trigger automatic graph processing)
    note_response = client.post("/api/v1/notes/", json={
        "title": "Team Meeting - Q4 Planning",
        "content": "John Smith from Acme Corp discussed Project Alpha timeline. We need to finalize the budget by next week. Sarah Johnson mentioned the UI changes are ready for review.",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note_response.status_code == 200
    note_data = note_response.json()
    note_id = note_data["id"]
    assert note_data["title"] == "Team Meeting - Q4 Planning"
    
    # Step 2: Manually trigger graph extraction
    extraction_response = client.post(f"/api/v1/notes/{note_id}/extract-graph", headers=auth_headers)
    
    assert extraction_response.status_code == 200
    extraction_data = extraction_response.json()
    assert "message" in extraction_data
    assert "triples_extracted" in extraction_data
    assert "triples_inserted" in extraction_data
    assert "processing_time" in extraction_data
    assert "model_used" in extraction_data
    assert extraction_data["triples_extracted"] == 2
    assert extraction_data["triples_inserted"] == 2
    
    # Step 3: Get graph context for the note
    context_response = client.get(f"/api/v1/notes/{note_id}/graph-context?max_depth=2&limit=50", headers=auth_headers)
    
    assert context_response.status_code == 200
    context_data = context_response.json()
    assert "note_id" in context_data
    assert "note_title" in context_data
    assert "context" in context_data
    assert context_data["note_id"] == note_id
    assert context_data["note_title"] == "Team Meeting - Q4 Planning"
    assert "entities" in context_data["context"]
    assert "relationships" in context_data["context"]
    assert "context_summary" in context_data["context"]
    assert len(context_data["context"]["entities"]) == 3
    
    # Step 4: Get graph statistics
    stats_response = client.get("/api/v1/notes/graph/stats", headers=auth_headers)
    
    assert stats_response.status_code == 200
    stats_data = stats_response.json()
    assert "total_nodes" in stats_data
    assert "entity_count" in stats_data
    assert "note_count" in stats_data
    assert "total_relationships" in stats_data
    assert "relationship_types" in stats_data
    assert "entity_type_distribution" in stats_data
    
    # Step 5: Check graph services health
    health_response = client.get("/api/v1/notes/graph/health")
    
    assert health_response.status_code == 200
    health_data = health_response.json()
    assert "extractor" in health_data
    assert "inserter" in health_data
    assert "retriever" in health_data
    assert health_data["extractor"]["status"] == "healthy"
    assert health_data["inserter"]["status"] == "healthy"
    assert health_data["retriever"]["status"] == "healthy"

def test_graph_processing_with_multiple_notes(auth_headers, mock_graph_services):
    """Test graph processing with multiple related notes"""
    
    # Create first note
    note1_response = client.post("/api/v1/notes/", json={
        "title": "Client Meeting - Acme Corp",
        "content": "John Smith from Acme Corp discussed Project Alpha requirements. Budget approved for Q4.",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note1_response.status_code == 200
    note1_id = note1_response.json()["id"]
    
    # Create second note
    note2_response = client.post("/api/v1/notes/", json={
        "title": "Project Alpha Update",
        "content": "John Smith reported progress on Project Alpha. Sarah Johnson from TechCorp will join the team next week.",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note2_response.status_code == 200
    note2_id = note2_response.json()["id"]
    
    # Extract graph for both notes
    extraction1_response = client.post(f"/api/v1/notes/{note1_id}/extract-graph", headers=auth_headers)
    extraction2_response = client.post(f"/api/v1/notes/{note2_id}/extract-graph", headers=auth_headers)
    
    assert extraction1_response.status_code == 200
    assert extraction2_response.status_code == 200
    
    # Get context for both notes
    context1_response = client.get(f"/api/v1/notes/{note1_id}/graph-context", headers=auth_headers)
    context2_response = client.get(f"/api/v1/notes/{note2_id}/graph-context", headers=auth_headers)
    
    assert context1_response.status_code == 200
    assert context2_response.status_code == 200
    
    # Both notes should have related entities
    context1_data = context1_response.json()
    context2_data = context2_response.json()
    
    assert "entities" in context1_data["context"]
    assert "entities" in context2_data["context"]
    assert len(context1_data["context"]["entities"]) >= 1
    assert len(context2_data["context"]["entities"]) >= 1

def test_graph_processing_error_handling(auth_headers):
    """Test graph processing error handling"""
    
    # Create a note
    note_response = client.post("/api/v1/notes/", json={
        "title": "Test Note",
        "content": "This is a test note for error handling.",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note_response.status_code == 200
    note_id = note_response.json()["id"]
    
    # Test extraction with service failure
    with patch('app.services.graph_client.graph_client.extract_triples') as mock_extract:
        mock_extract.side_effect = Exception("Service unavailable")
        
        extraction_response = client.post(f"/api/v1/notes/{note_id}/extract-graph", headers=auth_headers)
        
        assert extraction_response.status_code == 500
        extraction_data = extraction_response.json()
        assert "detail" in extraction_data
        assert "extraction failed" in extraction_data["detail"].lower()
    
    # Test context retrieval with service failure
    with patch('app.services.graph_client.graph_client.get_graph_context') as mock_context:
        mock_context.side_effect = Exception("Service unavailable")
        
        context_response = client.get(f"/api/v1/notes/{note_id}/graph-context", headers=auth_headers)
        
        assert context_response.status_code == 500
        context_data = context_response.json()
        assert "detail" in context_data
        assert "context retrieval failed" in context_data["detail"].lower()

def test_graph_processing_with_empty_content(auth_headers, mock_graph_services):
    """Test graph processing with notes that have no content"""
    
    # Create note with no content
    note_response = client.post("/api/v1/notes/", json={
        "title": "Empty Note",
        "content": "",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note_response.status_code == 200
    note_id = note_response.json()["id"]
    
    # Try to extract graph from empty note
    extraction_response = client.post(f"/api/v1/notes/{note_id}/extract-graph", headers=auth_headers)
    
    assert extraction_response.status_code == 400
    extraction_data = extraction_response.json()
    assert "detail" in extraction_data
    assert "no content" in extraction_data["detail"].lower()

def test_graph_processing_with_nonexistent_note(auth_headers, mock_graph_services):
    """Test graph processing with non-existent note"""
    
    # Try to get context for non-existent note
    context_response = client.get("/api/v1/notes/99999/graph-context", headers=auth_headers)
    
    assert context_response.status_code == 404
    context_data = context_response.json()
    assert "detail" in context_data
    assert "not found" in context_data["detail"].lower()
    
    # Try to extract graph from non-existent note
    extraction_response = client.post("/api/v1/notes/99999/extract-graph", headers=auth_headers)
    
    assert extraction_response.status_code == 404
    extraction_data = extraction_response.json()
    assert "detail" in extraction_data
    assert "not found" in extraction_data["detail"].lower()

def test_graph_services_health_check_failure():
    """Test graph services health check when services are down"""
    
    with patch('app.services.graph_client.graph_client.health_check') as mock_health:
        mock_health.side_effect = Exception("Service unavailable")
        
        health_response = client.get("/api/v1/notes/graph/health")
        
        assert health_response.status_code == 500
        health_data = health_response.json()
        assert "detail" in health_data
        assert "health check failed" in health_data["detail"].lower()

def test_graph_stats_error_handling(auth_headers):
    """Test graph stats error handling when services are down"""
    
    with patch('app.services.graph_client.graph_client.get_graph_stats') as mock_stats:
        mock_stats.side_effect = Exception("Service unavailable")
        
        stats_response = client.get("/api/v1/notes/graph/stats", headers=auth_headers)
        
        assert stats_response.status_code == 500
        stats_data = stats_response.json()
        assert "detail" in stats_data
        assert "stats retrieval failed" in stats_data["detail"].lower()

def test_graph_processing_performance(auth_headers, mock_graph_services):
    """Test graph processing performance with multiple operations"""
    
    import time
    
    # Create multiple notes
    note_ids = []
    for i in range(5):
        note_response = client.post("/api/v1/notes/", json={
            "title": f"Test Note {i+1}",
            "content": f"This is test note {i+1} about Project Alpha and John Smith from Acme Corp.",
            "source_type": "rocketbook"
        }, headers=auth_headers)
        
        assert note_response.status_code == 200
        note_ids.append(note_response.json()["id"])
    
    # Extract graph for all notes
    start_time = time.time()
    for note_id in note_ids:
        extraction_response = client.post(f"/api/v1/notes/{note_id}/extract-graph", headers=auth_headers)
        assert extraction_response.status_code == 200
    
    extraction_time = time.time() - start_time
    
    # Get context for all notes
    start_time = time.time()
    for note_id in note_ids:
        context_response = client.get(f"/api/v1/notes/{note_id}/graph-context", headers=auth_headers)
        assert context_response.status_code == 200
    
    context_time = time.time() - start_time
    
    # Performance should be reasonable (less than 10 seconds for 5 notes)
    assert extraction_time < 10.0
    assert context_time < 10.0

def test_graph_processing_data_consistency(auth_headers, mock_graph_services):
    """Test that graph processing maintains data consistency"""
    
    # Create a note with specific content
    note_response = client.post("/api/v1/notes/", json={
        "title": "Consistency Test",
        "content": "John Smith works for Acme Corp on Project Alpha. Sarah Johnson is the project manager.",
        "source_type": "rocketbook"
    }, headers=auth_headers)
    
    assert note_response.status_code == 200
    note_id = note_response.json()["id"]
    
    # Extract graph
    extraction_response = client.post(f"/api/v1/notes/{note_id}/extract-graph", headers=auth_headers)
    assert extraction_response.status_code == 200
    
    # Get context multiple times - should be consistent
    context1_response = client.get(f"/api/v1/notes/{note_id}/graph-context", headers=auth_headers)
    context2_response = client.get(f"/api/v1/notes/{note_id}/graph-context", headers=auth_headers)
    
    assert context1_response.status_code == 200
    assert context2_response.status_code == 200
    
    context1_data = context1_response.json()
    context2_data = context2_response.json()
    
    # Context should be consistent across multiple calls
    assert context1_data["note_id"] == context2_data["note_id"]
    assert context1_data["note_title"] == context2_data["note_title"]
    assert len(context1_data["context"]["entities"]) == len(context2_data["context"]["entities"])
    assert len(context1_data["context"]["relationships"]) == len(context2_data["context"]["relationships"])
